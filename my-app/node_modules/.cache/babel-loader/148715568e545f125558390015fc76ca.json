{"ast":null,"code":"import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\nimport * as NavigationActions from '../NavigationActions';\nimport * as SwitchActions from './SwitchActions';\nimport * as StackActions from './StackActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport { createPathParser } from './pathUtils';\n\nconst defaultActionCreators = () => ({});\n\nexport default ((routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n  const order = config.order || Object.keys(routeConfigs);\n  const getCustomActionCreators = config.getCustomActionCreators || defaultActionCreators;\n  const {\n    initialRouteParams\n  } = config;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur') ? config.resetOnBlur : true;\n  const initialRouteIndex = order.indexOf(initialRouteName);\n\n  if (initialRouteIndex === -1) {\n    throw new Error(\"Invalid initialRouteName '\".concat(initialRouteName, \"'.\") + \"Should be one of \".concat(order.map(n => \"\\\"\".concat(n, \"\\\"\")).join(', ')));\n  }\n\n  const childRouters = {};\n  order.forEach(routeName => {\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    let routeConfig = routeConfigs[routeName];\n\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params,\n        ...params\n      };\n    } else {\n      return params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams\n  } = createPathParser(childRouters, routeConfigs, config);\n\n  function resetChildRoute(routeName) {\n    let initialParams = routeName === initialRouteName ? initialRouteParams : null; // note(brentvatne): merging initialRouteParams *on top* of default params\n    // on the route seems incorrect but it's consistent with existing behavior\n    // in stackrouter\n\n    let params = getParamsForRoute(routeName, initialParams);\n    const childRouter = childRouters[routeName];\n\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return { ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        ...(params ? {\n          params\n        } : {})\n      };\n    }\n\n    return {\n      key: routeName,\n      routeName,\n      ...(params ? {\n        params\n      } : {})\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(prevState, nextState) {\n      if (backBehavior !== 'history' || prevState && nextState && nextState.index === prevState.index) {\n        return nextState;\n      }\n\n      let nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n\n        const keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter(k => k !== keyToAdd); // dedup\n\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n\n        nextRouteKeyHistory.pop();\n      }\n\n      return { ...nextState,\n        routeKeyHistory: nextRouteKeyHistory\n      };\n    }\n\n    let nextState = possibleNextState;\n\n    if (prevState && possibleNextState && prevState.index !== possibleNextState.index && resetOnBlur) {\n      const prevRouteName = prevState.routes[prevState.index].routeName;\n      const nextRoutes = [...possibleNextState.routes];\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = { ...possibleNextState,\n        routes: nextRoutes\n      };\n    }\n\n    return updateNextStateHistory(prevState, nextState);\n  }\n\n  function getInitialState() {\n    const routes = order.map(resetChildRoute);\n    const initialState = {\n      routes,\n      index: initialRouteIndex\n    };\n\n    if (backBehavior === 'history') {\n      const initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n\n    return initialState;\n  }\n\n  return {\n    childRouters,\n\n    getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState\n      } : inputState;\n      let state = inputState || getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const {\n          params\n        } = action;\n\n        if (params) {\n          state.routes = state.routes.map(route => ({ ...route,\n            params: { ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName ? initialRouteParams : null)\n            }\n          }));\n        }\n      }\n\n      if (action.type === SwitchActions.JUMP_TO && (action.key == null || action.key === state.key)) {\n        const {\n          params\n        } = action;\n        const index = state.routes.findIndex(route => route.routeName === action.routeName);\n\n        if (index === -1) {\n          throw new Error(\"There is no route named '\".concat(action.routeName, \"' in the navigator with the key '\").concat(action.key, \"'.\\n\") + \"Must be one of: \".concat(state.routes.map(route => \"'\".concat(route.routeName, \"'\")).join(',')));\n        }\n\n        return getNextState(action, prevState, { ...state,\n          routes: params ? state.routes.map((route, i) => i === index ? { ...route,\n            params: { ...route.params,\n              ...params\n            }\n          } : route) : state.routes,\n          index\n        });\n      } // Let the current child handle it\n\n\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(action, activeChildLastState);\n\n        if (!activeChildState && inputState) {\n          return null;\n        }\n\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, { ...state,\n            routes\n          });\n        }\n      } // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n\n\n      const isBackEligible = action.key == null || action.key === activeChildLastState.key;\n\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        } // The history contains current route, so we can only go back\n        // if there is more than one item in the history\n        else if (isBackEligible && backBehavior === 'history' && state.routeKeyHistory.length > 1) {\n          const routeKey = state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        }\n      }\n\n      let didNavigate = false;\n\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n\n          return false;\n        });\n\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          const childRouter = childRouters[action.routeName];\n          let newChildState = childState;\n\n          if (action.action && childRouter) {\n            const childStateUpdate = childRouter.getStateForAction(action.action, childState);\n\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = { ...newChildState,\n              params: { ...(newChildState.params || {}),\n                ...action.params\n              }\n            };\n          }\n\n          if (newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            const nextState = { ...state,\n              routes,\n              index: activeChildIndex\n            };\n            return getNextState(action, prevState, nextState);\n          } else if (newChildState === childState && state.index === activeChildIndex && prevState) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find(route => route.key === key);\n\n        if (lastRoute) {\n          const params = { ...lastRoute.params,\n            ...action.params\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = { ...lastRoute,\n            params\n          };\n          return getNextState(action, prevState, { ...state,\n            routes\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, { ...state,\n          index: activeChildIndex\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return { ...state\n        };\n      }\n\n      const isActionBackOrPop = action.type === NavigationActions.BACK || action.type === StackActions.POP || action.type === StackActions.POP_TO_TOP;\n      const sendActionToInactiveChildren = !isActionBackOrPop || action.type === NavigationActions.BACK && action.key != null; // Let other children handle it and switch to the first child that returns a new state\n      // Do not do this for StackActions.POP or NavigationActions.BACK actions without a key:\n      // it would be unintuitive for these actions to switch to another tab just because that tab had a Stack that could accept a back action\n\n      if (sendActionToInactiveChildren) {\n        let index = state.index;\n        let routes = state.routes;\n        order.find((childId, i) => {\n          const childRouter = childRouters[childId];\n\n          if (i === index) {\n            return false;\n          }\n\n          let childState = routes[i];\n\n          if (childRouter) {\n            childState = childRouter.getStateForAction(action, childState);\n          }\n\n          if (!childState) {\n            index = i;\n            return true;\n          }\n\n          if (childState !== routes[i]) {\n            routes = [...routes];\n            routes[i] = childState;\n            index = i;\n            return true;\n          }\n\n          return false;\n        }); // Nested routers can be updated after switching children with actions such as SET_PARAMS\n        // and COMPLETE_TRANSITION.\n\n        if (action.preserveFocus) {\n          index = state.index;\n        }\n\n        if (index !== state.index || routes !== state.routes) {\n          return getNextState(action, prevState, { ...state,\n            index,\n            routes\n          });\n        }\n      }\n\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(routeName, \"There is no route defined for index \".concat(state.index, \". Check that\\n        that you passed in a navigation state with a valid tab/screen index.\"));\n      const childRouter = childRouters[routeName];\n\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(routeConfigs, config.defaultNavigationOptions)\n  };\n});","map":{"version":3,"sources":["SwitchRouter.js"],"names":["defaultActionCreators","config","validateRouteConfigMap","order","Object","getCustomActionCreators","initialRouteParams","initialRouteName","backBehavior","resetOnBlur","initialRouteIndex","n","childRouters","routeName","screen","getScreenForRouteName","routeConfig","routeConfigs","params","getActionForPathAndParams","createPathParser","initialParams","getParamsForRoute","childRouter","childAction","NavigationActions","key","prevState","nextState","nextRouteKeyHistory","action","keyToAdd","k","routeKeyHistory","possibleNextState","prevRouteName","nextRoutes","resetChildRoute","routes","updateNextStateHistory","initialState","index","initialKey","getActionCreators","getStateForAction","inputState","state","getInitialState","activeChildIndex","route","SwitchActions","getNextState","activeChildLastState","activeChildRouter","activeChildState","isBackEligible","Math","routeKey","didNavigate","childId","childState","newChildState","childStateUpdate","lastRoute","isActionBackOrPop","StackActions","sendActionToInactiveChildren","i","getComponentForState","invariant","getComponentForRouteName","getPathAndParamsForState","getPathAndParamsForRoute","getScreenOptions","createConfigGetter"],"mappings":"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","sourcesContent":["import invariant from '../utils/invariant';\nimport getScreenForRouteName from './getScreenForRouteName';\nimport createConfigGetter from './createConfigGetter';\n\nimport * as NavigationActions from '../NavigationActions';\nimport * as SwitchActions from './SwitchActions';\nimport * as StackActions from './StackActions';\nimport validateRouteConfigMap from './validateRouteConfigMap';\nimport { createPathParser } from './pathUtils';\n\nconst defaultActionCreators = () => ({});\n\nexport default (routeConfigs, config = {}) => {\n  // Fail fast on invalid route definitions\n  validateRouteConfigMap(routeConfigs);\n\n  const order = config.order || Object.keys(routeConfigs);\n\n  const getCustomActionCreators =\n    config.getCustomActionCreators || defaultActionCreators;\n\n  const { initialRouteParams } = config;\n  const initialRouteName = config.initialRouteName || order[0];\n  const backBehavior = config.backBehavior || 'none';\n  const resetOnBlur = config.hasOwnProperty('resetOnBlur')\n    ? config.resetOnBlur\n    : true;\n\n  const initialRouteIndex = order.indexOf(initialRouteName);\n  if (initialRouteIndex === -1) {\n    throw new Error(\n      `Invalid initialRouteName '${initialRouteName}'.` +\n        `Should be one of ${order.map((n) => `\"${n}\"`).join(', ')}`\n    );\n  }\n\n  const childRouters = {};\n  order.forEach((routeName) => {\n    childRouters[routeName] = null;\n    const screen = getScreenForRouteName(routeConfigs, routeName);\n    if (screen.router) {\n      childRouters[routeName] = screen.router;\n    }\n  });\n\n  function getParamsForRoute(routeName, params) {\n    let routeConfig = routeConfigs[routeName];\n    if (routeConfig && routeConfig.params) {\n      return { ...routeConfig.params, ...params };\n    } else {\n      return params;\n    }\n  }\n\n  const {\n    getPathAndParamsForRoute,\n    getActionForPathAndParams,\n  } = createPathParser(childRouters, routeConfigs, config);\n\n  function resetChildRoute(routeName) {\n    let initialParams =\n      routeName === initialRouteName ? initialRouteParams : null;\n    // note(brentvatne): merging initialRouteParams *on top* of default params\n    // on the route seems incorrect but it's consistent with existing behavior\n    // in stackrouter\n    let params = getParamsForRoute(routeName, initialParams);\n    const childRouter = childRouters[routeName];\n    if (childRouter) {\n      const childAction = NavigationActions.init();\n      return {\n        ...childRouter.getStateForAction(childAction),\n        key: routeName,\n        routeName,\n        ...(params ? { params } : {}),\n      };\n    }\n    return {\n      key: routeName,\n      routeName,\n      ...(params ? { params } : {}),\n    };\n  }\n\n  function getNextState(action, prevState, possibleNextState) {\n    function updateNextStateHistory(prevState, nextState) {\n      if (\n        backBehavior !== 'history' ||\n        (prevState && nextState && nextState.index === prevState.index)\n      ) {\n        return nextState;\n      }\n      let nextRouteKeyHistory = prevState ? prevState.routeKeyHistory : [];\n      if (action.type === NavigationActions.NAVIGATE) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n        const keyToAdd = nextState.routes[nextState.index].key;\n        nextRouteKeyHistory = nextRouteKeyHistory.filter((k) => k !== keyToAdd); // dedup\n        nextRouteKeyHistory.push(keyToAdd);\n      } else if (action.type === NavigationActions.BACK) {\n        nextRouteKeyHistory = [...nextRouteKeyHistory]; // copy\n        nextRouteKeyHistory.pop();\n      }\n      return {\n        ...nextState,\n        routeKeyHistory: nextRouteKeyHistory,\n      };\n    }\n\n    let nextState = possibleNextState;\n    if (\n      prevState &&\n      possibleNextState &&\n      prevState.index !== possibleNextState.index &&\n      resetOnBlur\n    ) {\n      const prevRouteName = prevState.routes[prevState.index].routeName;\n      const nextRoutes = [...possibleNextState.routes];\n      nextRoutes[prevState.index] = resetChildRoute(prevRouteName);\n      nextState = {\n        ...possibleNextState,\n        routes: nextRoutes,\n      };\n    }\n    return updateNextStateHistory(prevState, nextState);\n  }\n\n  function getInitialState() {\n    const routes = order.map(resetChildRoute);\n    const initialState = {\n      routes,\n      index: initialRouteIndex,\n    };\n\n    if (backBehavior === 'history') {\n      const initialKey = routes[initialRouteIndex].key;\n      initialState['routeKeyHistory'] = [initialKey];\n    }\n    return initialState;\n  }\n\n  return {\n    childRouters,\n\n    getActionCreators(route, stateKey) {\n      return getCustomActionCreators(route, stateKey);\n    },\n\n    getStateForAction(action, inputState) {\n      let prevState = inputState ? { ...inputState } : inputState;\n      let state = inputState || getInitialState();\n      let activeChildIndex = state.index;\n\n      if (action.type === NavigationActions.INIT) {\n        // NOTE(brentvatne): this seems weird... why are we merging these\n        // params into child routes?\n        // ---------------------------------------------------------------\n        // Merge any params from the action into all the child routes\n        const { params } = action;\n        if (params) {\n          state.routes = state.routes.map((route) => ({\n            ...route,\n            params: {\n              ...route.params,\n              ...params,\n              ...(route.routeName === initialRouteName\n                ? initialRouteParams\n                : null),\n            },\n          }));\n        }\n      }\n\n      if (\n        action.type === SwitchActions.JUMP_TO &&\n        (action.key == null || action.key === state.key)\n      ) {\n        const { params } = action;\n        const index = state.routes.findIndex(\n          (route) => route.routeName === action.routeName\n        );\n\n        if (index === -1) {\n          throw new Error(\n            `There is no route named '${action.routeName}' in the navigator with the key '${action.key}'.\\n` +\n              `Must be one of: ${state.routes\n                .map((route) => `'${route.routeName}'`)\n                .join(',')}`\n          );\n        }\n\n        return getNextState(action, prevState, {\n          ...state,\n          routes: params\n            ? state.routes.map((route, i) =>\n                i === index\n                  ? {\n                      ...route,\n                      params: {\n                        ...route.params,\n                        ...params,\n                      },\n                    }\n                  : route\n              )\n            : state.routes,\n          index,\n        });\n      }\n\n      // Let the current child handle it\n      const activeChildLastState = state.routes[state.index];\n      const activeChildRouter = childRouters[order[state.index]];\n      if (activeChildRouter) {\n        const activeChildState = activeChildRouter.getStateForAction(\n          action,\n          activeChildLastState\n        );\n        if (!activeChildState && inputState) {\n          return null;\n        }\n        if (activeChildState && activeChildState !== activeChildLastState) {\n          const routes = [...state.routes];\n          routes[state.index] = activeChildState;\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      // Handle tab changing. Do this after letting the current tab try to\n      // handle the action, to allow inner children to change first\n      const isBackEligible =\n        action.key == null || action.key === activeChildLastState.key;\n      if (action.type === NavigationActions.BACK) {\n        if (isBackEligible && backBehavior === 'initialRoute') {\n          activeChildIndex = initialRouteIndex;\n        } else if (isBackEligible && backBehavior === 'order') {\n          activeChildIndex = Math.max(0, activeChildIndex - 1);\n        }\n        // The history contains current route, so we can only go back\n        // if there is more than one item in the history\n        else if (\n          isBackEligible &&\n          backBehavior === 'history' &&\n          state.routeKeyHistory.length > 1\n        ) {\n          const routeKey =\n            state.routeKeyHistory[state.routeKeyHistory.length - 2];\n          activeChildIndex = order.indexOf(routeKey);\n        }\n      }\n\n      let didNavigate = false;\n      if (action.type === NavigationActions.NAVIGATE) {\n        didNavigate = !!order.find((childId, i) => {\n          if (childId === action.routeName) {\n            activeChildIndex = i;\n            return true;\n          }\n          return false;\n        });\n        if (didNavigate) {\n          const childState = state.routes[activeChildIndex];\n          const childRouter = childRouters[action.routeName];\n          let newChildState = childState;\n\n          if (action.action && childRouter) {\n            const childStateUpdate = childRouter.getStateForAction(\n              action.action,\n              childState\n            );\n            if (childStateUpdate) {\n              newChildState = childStateUpdate;\n            }\n          }\n\n          if (action.params) {\n            newChildState = {\n              ...newChildState,\n              params: {\n                ...(newChildState.params || {}),\n                ...action.params,\n              },\n            };\n          }\n\n          if (newChildState !== childState) {\n            const routes = [...state.routes];\n            routes[activeChildIndex] = newChildState;\n            const nextState = {\n              ...state,\n              routes,\n              index: activeChildIndex,\n            };\n            return getNextState(action, prevState, nextState);\n          } else if (\n            newChildState === childState &&\n            state.index === activeChildIndex &&\n            prevState\n          ) {\n            return null;\n          }\n        }\n      }\n\n      if (action.type === NavigationActions.SET_PARAMS) {\n        const key = action.key;\n        const lastRoute = state.routes.find((route) => route.key === key);\n        if (lastRoute) {\n          const params = {\n            ...lastRoute.params,\n            ...action.params,\n          };\n          const routes = [...state.routes];\n          routes[state.routes.indexOf(lastRoute)] = {\n            ...lastRoute,\n            params,\n          };\n          return getNextState(action, prevState, {\n            ...state,\n            routes,\n          });\n        }\n      }\n\n      if (activeChildIndex !== state.index) {\n        return getNextState(action, prevState, {\n          ...state,\n          index: activeChildIndex,\n        });\n      } else if (didNavigate && !inputState) {\n        return state;\n      } else if (didNavigate) {\n        return { ...state };\n      }\n\n      const isActionBackOrPop =\n        action.type === NavigationActions.BACK ||\n        action.type === StackActions.POP ||\n        action.type === StackActions.POP_TO_TOP;\n      const sendActionToInactiveChildren =\n        !isActionBackOrPop ||\n        (action.type === NavigationActions.BACK && action.key != null);\n\n      // Let other children handle it and switch to the first child that returns a new state\n      // Do not do this for StackActions.POP or NavigationActions.BACK actions without a key:\n      // it would be unintuitive for these actions to switch to another tab just because that tab had a Stack that could accept a back action\n      if (sendActionToInactiveChildren) {\n        let index = state.index;\n        let routes = state.routes;\n        order.find((childId, i) => {\n          const childRouter = childRouters[childId];\n          if (i === index) {\n            return false;\n          }\n          let childState = routes[i];\n          if (childRouter) {\n            childState = childRouter.getStateForAction(action, childState);\n          }\n          if (!childState) {\n            index = i;\n            return true;\n          }\n          if (childState !== routes[i]) {\n            routes = [...routes];\n            routes[i] = childState;\n            index = i;\n            return true;\n          }\n          return false;\n        });\n\n        // Nested routers can be updated after switching children with actions such as SET_PARAMS\n        // and COMPLETE_TRANSITION.\n        if (action.preserveFocus) {\n          index = state.index;\n        }\n\n        if (index !== state.index || routes !== state.routes) {\n          return getNextState(action, prevState, {\n            ...state,\n            index,\n            routes,\n          });\n        }\n      }\n\n      return state;\n    },\n\n    getComponentForState(state) {\n      const routeName = state.routes[state.index].routeName;\n      invariant(\n        routeName,\n        `There is no route defined for index ${state.index}. Check that\n        that you passed in a navigation state with a valid tab/screen index.`\n      );\n      const childRouter = childRouters[routeName];\n      if (childRouter) {\n        return childRouter.getComponentForState(state.routes[state.index]);\n      }\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getComponentForRouteName(routeName) {\n      return getScreenForRouteName(routeConfigs, routeName);\n    },\n\n    getPathAndParamsForState(state) {\n      const route = state.routes[state.index];\n      return getPathAndParamsForRoute(route);\n    },\n\n    getActionForPathAndParams(path, params) {\n      return getActionForPathAndParams(path, params);\n    },\n\n    getScreenOptions: createConfigGetter(\n      routeConfigs,\n      config.defaultNavigationOptions\n    ),\n  };\n};\n"]},"metadata":{},"sourceType":"module"}