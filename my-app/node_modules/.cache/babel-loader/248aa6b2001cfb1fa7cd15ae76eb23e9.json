{"ast":null,"code":"import getChildRouter from './getChildRouter';\nimport getNavigationActionCreators from './routers/getNavigationActionCreators';\nimport getChildrenNavigationCache from './getChildrenNavigationCache';\nimport getEventManager from './getEventManager';\n\nconst createParamGetter = route => (paramName, defaultValue) => {\n  const params = route.params;\n\n  if (params && paramName in params) {\n    return params[paramName];\n  }\n\n  return defaultValue;\n};\n\nfunction getChildNavigation(navigation, childKey, getCurrentParentNavigation) {\n  const children = getChildrenNavigationCache(navigation);\n  const childRoute = navigation.state.routes.find(r => r.key === childKey);\n\n  if (!childRoute) {\n    return null;\n  }\n\n  if (children[childKey] && children[childKey].state === childRoute) {\n    return children[childKey];\n  }\n\n  const childRouter = getChildRouter(navigation.router, childRoute.routeName); // If the route has children, we'll use this to pass in to the action creators\n  // for the childRouter so that any action that depends on the active route will\n  // behave as expected. We don't explicitly require that routers implement routes\n  // and index properties, but if we did then we would put an invariant here to\n  // ensure that a focusedGrandChildRoute exists if childRouter is defined.\n\n  const focusedGrandChildRoute = childRoute.routes && typeof childRoute.index === 'number' ? childRoute.routes[childRoute.index] : null;\n  const actionCreators = { ...navigation.actions,\n    ...navigation.router.getActionCreators(childRoute, navigation.state.key),\n    ...(childRouter ? childRouter.getActionCreators(focusedGrandChildRoute, childRoute.key) : {}),\n    ...getNavigationActionCreators(childRoute)\n  };\n  const actionHelpers = {};\n  Object.keys(actionCreators).forEach(actionName => {\n    actionHelpers[actionName] = (...args) => {\n      const actionCreator = actionCreators[actionName];\n      const action = actionCreator(...args);\n      return navigation.dispatch(action);\n    };\n  });\n  let isFirstRouteInParent = true;\n  const parentNavigation = getCurrentParentNavigation();\n\n  if (parentNavigation) {\n    isFirstRouteInParent = parentNavigation.state.routes.indexOf(childRoute) === 0;\n  }\n\n  if (children[childKey] && children[childKey].isFirstRouteInParent() === isFirstRouteInParent) {\n    children[childKey] = { ...children[childKey],\n      ...actionHelpers,\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute)\n    };\n    return children[childKey];\n  } else {\n    const {\n      addListener,\n      emit\n    } = getEventManager(childKey);\n    children[childKey] = { ...actionHelpers,\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n      getChildNavigation: grandChildKey => getChildNavigation(children[childKey], grandChildKey, () => {\n        const nav = getCurrentParentNavigation();\n        return nav && nav.getChildNavigation(childKey);\n      }),\n      isFocused: () => {\n        const currentNavigation = getCurrentParentNavigation();\n\n        if (!currentNavigation) {\n          return false;\n        }\n\n        const {\n          routes,\n          index\n        } = currentNavigation.state;\n\n        if (!currentNavigation.isFocused()) {\n          return false;\n        }\n\n        if (routes[index].key === childKey) {\n          return true;\n        }\n\n        return false;\n      },\n      isFirstRouteInParent: () => isFirstRouteInParent,\n      dispatch: navigation.dispatch,\n      getScreenProps: navigation.getScreenProps,\n      dangerouslyGetParent: getCurrentParentNavigation,\n      addListener,\n      emit\n    };\n    return children[childKey];\n  }\n}\n\nexport default getChildNavigation;","map":{"version":3,"sources":["getChildNavigation.js"],"names":["createParamGetter","route","params","paramName","children","getChildrenNavigationCache","childRoute","navigation","r","childRouter","getChildRouter","focusedGrandChildRoute","actionCreators","getNavigationActionCreators","actionHelpers","Object","actionName","actionCreator","action","isFirstRouteInParent","parentNavigation","getCurrentParentNavigation","state","router","actions","getParam","emit","getEventManager","getChildNavigation","grandChildKey","nav","isFocused","currentNavigation","index","routes","dispatch","getScreenProps","dangerouslyGetParent"],"mappings":"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","sourcesContent":["import getChildRouter from './getChildRouter';\nimport getNavigationActionCreators from './routers/getNavigationActionCreators';\nimport getChildrenNavigationCache from './getChildrenNavigationCache';\nimport getEventManager from './getEventManager';\n\nconst createParamGetter = (route) => (paramName, defaultValue) => {\n  const params = route.params;\n\n  if (params && paramName in params) {\n    return params[paramName];\n  }\n\n  return defaultValue;\n};\n\nfunction getChildNavigation(navigation, childKey, getCurrentParentNavigation) {\n  const children = getChildrenNavigationCache(navigation);\n  const childRoute = navigation.state.routes.find((r) => r.key === childKey);\n\n  if (!childRoute) {\n    return null;\n  }\n\n  if (children[childKey] && children[childKey].state === childRoute) {\n    return children[childKey];\n  }\n\n  const childRouter = getChildRouter(navigation.router, childRoute.routeName);\n\n  // If the route has children, we'll use this to pass in to the action creators\n  // for the childRouter so that any action that depends on the active route will\n  // behave as expected. We don't explicitly require that routers implement routes\n  // and index properties, but if we did then we would put an invariant here to\n  // ensure that a focusedGrandChildRoute exists if childRouter is defined.\n  const focusedGrandChildRoute =\n    childRoute.routes && typeof childRoute.index === 'number'\n      ? childRoute.routes[childRoute.index]\n      : null;\n\n  const actionCreators = {\n    ...navigation.actions,\n    ...navigation.router.getActionCreators(childRoute, navigation.state.key),\n    ...(childRouter\n      ? childRouter.getActionCreators(focusedGrandChildRoute, childRoute.key)\n      : {}),\n    ...getNavigationActionCreators(childRoute),\n  };\n\n  const actionHelpers = {};\n  Object.keys(actionCreators).forEach((actionName) => {\n    actionHelpers[actionName] = (...args) => {\n      const actionCreator = actionCreators[actionName];\n      const action = actionCreator(...args);\n      return navigation.dispatch(action);\n    };\n  });\n\n  let isFirstRouteInParent = true;\n\n  const parentNavigation = getCurrentParentNavigation();\n\n  if (parentNavigation) {\n    isFirstRouteInParent =\n      parentNavigation.state.routes.indexOf(childRoute) === 0;\n  }\n\n  if (\n    children[childKey] &&\n    children[childKey].isFirstRouteInParent() === isFirstRouteInParent\n  ) {\n    children[childKey] = {\n      ...children[childKey],\n      ...actionHelpers,\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n    };\n    return children[childKey];\n  } else {\n    const { addListener, emit } = getEventManager(childKey);\n\n    children[childKey] = {\n      ...actionHelpers,\n\n      state: childRoute,\n      router: childRouter,\n      actions: actionCreators,\n      getParam: createParamGetter(childRoute),\n\n      getChildNavigation: (grandChildKey) =>\n        getChildNavigation(children[childKey], grandChildKey, () => {\n          const nav = getCurrentParentNavigation();\n          return nav && nav.getChildNavigation(childKey);\n        }),\n\n      isFocused: () => {\n        const currentNavigation = getCurrentParentNavigation();\n        if (!currentNavigation) {\n          return false;\n        }\n        const { routes, index } = currentNavigation.state;\n        if (!currentNavigation.isFocused()) {\n          return false;\n        }\n        if (routes[index].key === childKey) {\n          return true;\n        }\n        return false;\n      },\n      isFirstRouteInParent: () => isFirstRouteInParent,\n      dispatch: navigation.dispatch,\n      getScreenProps: navigation.getScreenProps,\n      dangerouslyGetParent: getCurrentParentNavigation,\n      addListener,\n      emit,\n    };\n\n    return children[childKey];\n  }\n}\n\nexport default getChildNavigation;\n"]},"metadata":{},"sourceType":"module"}